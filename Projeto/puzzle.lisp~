;;; puzzle.lisp
;;; Dominio do jogo Solitario 2 (Fase 2)

;;; ---------------------------------------------------------
;;; 1. SELETORES E AUXILIARES (Comum)
;;; ---------------------------------------------------------

(defun linha (l tabuleiro)
  "Retorna a linha l do tabuleiro (1-indexada)."
  (nth (1- l) tabuleiro))

(defun celula (l c tab)
  (if (or (< l 1) (> l 7) (< c 1) (> c 7)) 
      nil 
      (nth (1- c) (nth (1- l) tab))))

;;; ---------------------------------------------------------
;;; 2. MODIFICADORES (Funcionais)
;;; ---------------------------------------------------------

(defun substituir-posicao (i lista v)
  (cond ((null lista) nil) ((= i 1) (cons v (cdr lista))) (t (cons (car lista) (substituir-posicao (1- i) (cdr lista) v)))))

(defun substituir (l c tab v)
  (cond ((null tab) nil)
        ((= l 1) (cons (substituir-posicao c (car tab) v) (cdr tab)))
        (t (cons (car tab) (substituir (1- l) c (cdr tab) v)))))

;;; =========================================================
;;; FASE 1: LOGICA (1 JOGADOR - CAPTURA A PROPRIA PECA)
;;; =========================================================

(defun aplicar-movimento (l c tabuleiro dl dc)
  "FASE 1: Aplica salto onde Origem(1)->0, Meio(1)->0, Destino(0)->1"
  (let* ((l-dest (+ l dl))
         (c-dest (+ c dc))
         (l-meio (+ l (/ dl 2)))
         (c-meio (+ c (/ dc 2))))
    (substituir l-dest c-dest
                (substituir l-meio c-meio
                            (substituir l c tabuleiro 0)
                            0)
                1))) ;; Na fase 1, quem joga e sempre o '1'

(defun operador-cd (l c tab)
  "FASE 1: Captura Direita"
  (if (<= (+ c 2) 7)
      (let ((orig (celula l c tab)) (meio (celula l (1+ c) tab)) (dest (celula l (+ c 2) tab)))
        (if (and (eql orig 1) (eql meio 1) (eql dest 0))
            (aplicar-movimento l c tab 0 2)
            nil)) nil))

(defun operador-ce (l c tab)
  "FASE 1: Captura Esquerda"
  (if (>= (- c 2) 1)
      (let ((orig (celula l c tab)) (meio (celula l (1- c) tab)) (dest (celula l (- c 2) tab)))
        (if (and (eql orig 1) (eql meio 1) (eql dest 0))
            (aplicar-movimento l c tab 0 -2)
            nil)) nil))

(defun operador-cc (l c tab)
  "FASE 1: Captura Cima"
  (if (>= (- l 2) 1)
      (let ((orig (celula l c tab)) (meio (celula (1- l) c tab)) (dest (celula (- l 2) c tab)))
        (if (and (eql orig 1) (eql meio 1) (eql dest 0))
            (aplicar-movimento l c tab -2 0)
            nil)) nil))

(defun operador-cb (l c tab)
  "FASE 1: Captura Baixo"
  (if (<= (+ l 2) 7)
      (let ((orig (celula l c tab)) (meio (celula (1+ l) c tab)) (dest (celula (+ l 2) c tab)))
        (if (and (eql orig 1) (eql meio 1) (eql dest 0))
            (aplicar-movimento l c tab 2 0)
            nil)) nil))

(defun operadores ()
  "Retorna a lista de funcoes operadores para a FASE 1."
  (list #'operador-cd #'operador-ce #'operador-cc #'operador-cb))

;; Heuristicas FASE 1
(defun contar-pinos (tabuleiro)
  (if (null tabuleiro) 0
      (+ (count 1 (car tabuleiro)) (contar-pinos (cdr tabuleiro)))))

(defun peca-movel-p (l c tab)
  (or (operador-cd l c tab) (operador-ce l c tab) (operador-cc l c tab) (operador-cb l c tab)))

(defun contar-pecas-moveis (tab l c)
  (cond ((> l 7) 0)
        ((> c 7) (contar-pecas-moveis tab (1+ l) 1))
        (t (+ (if (peca-movel-p l c tab) 1 0) (contar-pecas-moveis tab l (1+ c))))))

(defun h1-base (estado) (/ 1.0 (1+ (contar-pecas-moveis estado 1 1))))
(defun h2-extra (estado) (1- (contar-pinos estado)))

;;; =========================================================
;;; FASE 2: ATUALIZACOES (2 JOGADORES - CAPTURA ADVERSARIO)
;;; =========================================================

(defun adversario (jogador)
  (if (= jogador 1) 2 1))

(defun aplicar-movimento-fase2 (l c tabuleiro dl dc jogador tipo)
  "FASE 2: Aplica movimento. Tipo :simples ou :captura"
  (let ((l-dest (+ l dl))
        (c-dest (+ c dc)))
    (if (eq tipo :captura)
        ;; Logica de captura: remove a peca do meio
        (let ((l-meio (+ l (/ dl 2)))
              (c-meio (+ c (/ dc 2))))
          (substituir l-dest c-dest
                      (substituir l-meio c-meio
                                  (substituir l c tabuleiro 0)
                                  0)
                      jogador))
        ;; Logica simples: move apenas
        (substituir l-dest c-dest (substituir l c tabuleiro 0) jogador))))

;; Novos Operadores Simples (d, e, c, b)
(defun operador-d (l c tab jogador)
  (if (<= (1+ c) 7)
      (let ((dest (celula l (1+ c) tab)))
        (if (and (eql (celula l c tab) jogador) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 0 1 jogador :simples) nil)) nil))

(defun operador-e (l c tab jogador)
  (if (>= (1- c) 1)
      (let ((dest (celula l (1- c) tab)))
        (if (and (eql (celula l c tab) jogador) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 0 -1 jogador :simples) nil)) nil))

(defun operador-c (l c tab jogador)
  (if (>= (1- l) 1)
      (let ((dest (celula (1- l) c tab)))
        (if (and (eql (celula l c tab) jogador) (eql dest 0))
            (aplicar-movimento-fase2 l c tab -1 0 jogador :simples) nil)) nil))

(defun operador-b (l c tab jogador)
  (if (<= (1+ l) 7)
      (let ((dest (celula (1+ l) c tab)))
        (if (and (eql (celula l c tab) jogador) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 1 0 jogador :simples) nil)) nil))

;; Operadores de Captura FASE 2 (Verifica Adversario)
(defun operador-cd-2 (l c tab jogador)
  (if (<= (+ c 2) 7)
      (let ((orig (celula l c tab)) (meio (celula l (1+ c) tab)) (dest (celula l (+ c 2) tab)))
        (if (and (eql orig jogador) (eql meio (adversario jogador)) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 0 2 jogador :captura) nil)) nil))

(defun operador-ce-2 (l c tab jogador)
  (if (>= (- c 2) 1)
      (let ((orig (celula l c tab)) (meio (celula l (1- c) tab)) (dest (celula l (- c 2) tab)))
        (if (and (eql orig jogador) (eql meio (adversario jogador)) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 0 -2 jogador :captura) nil)) nil))

(defun operador-cc-2 (l c tab jogador)
  (if (>= (- l 2) 1)
      (let ((orig (celula l c tab)) (meio (celula (1- l) c tab)) (dest (celula (- l 2) c tab)))
        (if (and (eql orig jogador) (eql meio (adversario jogador)) (eql dest 0))
            (aplicar-movimento-fase2 l c tab -2 0 jogador :captura) nil)) nil))

(defun operador-cb-2 (l c tab jogador)
  (if (<= (+ l 2) 7)
      (let ((orig (celula l c tab)) (meio (celula (1+ l) c tab)) (dest (celula (+ l 2) c tab)))
        (if (and (eql orig jogador) (eql meio (adversario jogador)) (eql dest 0))
            (aplicar-movimento-fase2 l c tab 2 0 jogador :captura) nil)) nil))

;; Funcao de Avaliacao FASE 2
(defun soma-linhas (tab linha-atual jogador)
  (if (null tab) 0
      (+ (* (count jogador (car tab)) linha-atual)
         (soma-linhas (cdr tab) (1+ linha-atual) jogador))))

(defun soma-linhas-inv (tab linha-atual jogador)
  (if (null tab) 0
      (+ (* (count jogador (car tab)) (- 8 linha-atual))
         (soma-linhas-inv (cdr tab) (1+ linha-atual) jogador))))

(defun avaliar-estado (estado jogador)
  (let ((p1 (soma-linhas estado 1 1))
        (p2 (soma-linhas-inv estado 1 2)))
    (if (= jogador 1) (- p1 p2) (- p2 p1))))

(defun gerar-todos-sucessores (tab j)
  (gerar-sucessores-rec tab j 1 1))

(defun gerar-sucessores-rec (tab j l c)
  "Corrigido: Aceita exatamente TAB J L C para evitar erro de definicao."
  (cond ((> l 7) nil)
        ((> c 7) (gerar-sucessores-rec tab j (1+ l) 1))
        (t (append (tentar-movimentos l c tab j) (gerar-sucessores-rec tab j l (1+ c))))))

(defun tentar-movimentos (l c tab j)
  (let ((ops '((d 0 1 nil) (e 0 -1 nil) (c -1 0 nil) (b 1 0 nil)
               (cd 0 2 t) (ce 0 -2 t) (cc -2 0 t) (cb 2 0 t))))
    (mapcan (lambda (o)
              (let ((res (validar-e-aplicar l c tab j (second o) (third o) (fourth o))))
                (if res (list (cons (list (car o) l c) res)) nil)))
            ops)))

(defun validar-e-aplicar (l c tab j dl dc cap)
  (let ((nl (+ l dl)) (nc (+ c dc)) (adv (if (= j 1) 2 1)))
    (if (and (eql (celula l c tab) j) (eql (celula nl nc tab) 0))
        (if cap
            (let ((ml (+ l (/ dl 2))) (mc (+ c (/ dc 2))))
              (if (eql (celula ml mc tab) adv)
                  (substituir nl nc (substituir ml mc (substituir l c tab 0) 0) j) nil))
            (substituir nl nc (substituir l c tab 0) j))
        nil)))

(defun avaliar-estado (tab j)
  "Garante retorno numerico para evitar erro (+ NIL NIL)."
  (let ((eu (or (contar-pecas tab j) 0)) 
        (ele (or (contar-pecas tab (if (= j 1) 2 1)) 0)))
    (+ (* 100 (- eu ele)) (or (bonus-alvo tab j) 0))))

(defun contar-pecas (tab j) (reduce #'+ (mapcar (lambda (lin) (count j lin)) tab)))

(defun bonus-alvo (tab j)
  (let ((alvos (if (= j 1) '((6 3) (6 4) (6 5) (7 3) (7 4) (7 5)) '((1 3) (1 4) (1 5) (2 3) (2 4) (2 5)))))
    (if (some (lambda (a) (eql (celula (first a) (second a) tab) j)) alvos) 5000 0)))