;;; procura.lisp - Algoritmos de Procura (Fase 1)
;;; Codigo gerado automaticamente conforme normas de programacao funcional.

(defun criar-no (estado &optional (g 0) (h 0) (pai nil)) (list estado g h pai))
(defun no-estado (no) (first no))
(defun no-g (no) (second no))
(defun no-heuristica (no) (third no))
(defun no-pai (no) (fourth no))
(defun no-custo (no) (+ (no-g no) (no-heuristica no)))

(defun solucaop (no) (= (contar-pinos (no-estado no)) 1))
(defun ordenar-nos (lista) (sort (copy-list lista) #'< :key #'no-custo))

(defun gerar-sucessores-f1 (no h-fn)
  (let ((estado (no-estado no)) (g (no-g no)))
    (mapcan (lambda (l)
              (mapcan (lambda (c)
                        (mapcan (lambda (op)
                                  (let ((res (funcall op l c estado)))
                                    (if res (list (criar-no res (1+ g) (if h-fn (funcall h-fn res) 0) no)) nil)))
                                (operadores-f1)))
                      '(1 2 3 4 5 6 7)))
            '(1 2 3 4 5 6 7))))

(defun bfs (no-inicial)
  (declare (optimize (speed 3) (safety 0) (debug 0)))
  (let ((inicio (get-internal-run-time)))
    (labels ((bfs-rec (abertos fechados ger exp)
               (if (null abertos) nil
                   (let ((atual (car abertos)))
                     (if (solucaop atual)
                         (list atual ger exp (- (get-internal-run-time) inicio))
                         (if (member (no-estado atual) fechados :test #'equal)
                             (bfs-rec (cdr abertos) fechados ger exp)
                             (let ((suc (gerar-sucessores-f1 atual nil)))
                               (bfs-rec (append (cdr abertos) suc) (cons (no-estado atual) fechados) (+ ger (length suc)) (1+ exp)))))))))
      (bfs-rec (list no-inicial) nil 1 0))))

(defun a-star (no-inicial h-fn)
  (declare (optimize (speed 3) (safety 0) (debug 0)))
  (let ((inicio (get-internal-run-time)))
    (labels ((as-rec (abertos fechados ger exp)
               (if (null abertos) nil
                   (let ((atual (car abertos)))
                     (if (solucaop atual)
                         (list atual ger exp (- (get-internal-run-time) inicio))
                         (if (member (no-estado atual) fechados :test #'equal)
                             (as-rec (cdr abertos) fechados ger exp)
                             (let ((suc (gerar-sucessores-f1 atual h-fn)))
                               (as-rec (ordenar-nos (append (cdr abertos) suc)) (cons (no-estado atual) fechados) (+ ger (length suc)) (1+ exp)))))))))
      (as-rec (list no-inicial) nil 1 0))))